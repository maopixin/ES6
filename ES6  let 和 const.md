## 变量与常量
- 变量（let）:

1. 在同域下不能多次声明一个变量名
2. 暂存死区（没有预解析），在变量的上方打印不出undefined，而是报错
3. 不会在window下创建这个变量。
     
```javascript
//1. 块级作用域下声明两个变量
{
    var num = 1;
    let num2 = 1;
}
console.log(num); //1
console.log(num2); // 报错  num2 is not defined

//let所声明的变量，只在let命令所在的代码块内有效。

```
```javascript
// 2. for循环应用
var arr = []
for(let i=0;i<10;i++){
    arr[i] = function(){
        console.log(i);
    };
};
arr[0](); //0

console.log(i) // 报错  i is not defined

var arr = []
for(var i=0;i<10;i++){
    arr[i] = function(){
        console.log(i);
    };
};
arr[0](); //10

console.log(i) // 10

//通过以上代码可以看出  let声明的变量的作用域只在let命令所在的代码块内有效。
//而且 for循环 通过var声明的变量 在循环体之外 依然存在  造成变量泄露

```
```javascript
//3. let声明下的for循环

//for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
for(let i=0;i<10;i++){
   let i = '么么哒';
   console.log(i);
};
//以上代码执行  打印了10次么么哒  这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。


```
       
            
- 常量:(const)  ***声明一个只读的常量。一旦声明，常量的值就不能改变。***

1. 在同域下不能多次声明一个变量名
2. 暂存死区（没有预解析），在变量的上方打印不出undefined，而是报错
3. 不会在window下创建这个变量。
4. ***立即声明立即赋值使用***
5. 不可变的量，要变就报错

**const**实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，***保存的只是一个指针***，***const***只能***保证***这个***指针是固定的***，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
    
```javascript

const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only

```
***上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。***
